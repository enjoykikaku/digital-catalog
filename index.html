<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>エンジョイホーム デジタルカタログ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="./turn.min.js"></script>
  <style>
    body { margin: 0; background: #222; overflow: hidden; height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; }
    #flipbook { visibility: hidden; margin: 0 auto; }
    .page { background: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    canvas { width: 100%; height: 100%; display: block; }
    /* 読み込み中のインジケーター */
    #loader { color: white; position: absolute; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="loader">カタログを生成中...</div>
  <div id="flipbook"></div>

  <script>
    const url = './catalog.pdf';
    // Workerのパスを確実に通す
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    function isWide() { return window.innerWidth > 900; }

    async function buildFlipbook() {
      try {
        const flipbook = $('#flipbook');
        const pdf = await pdfjsLib.getDocument(url).promise;
        let firstW = 0, firstH = 0;

        // 描画負荷を抑えるため、先に枠組みだけ作る
        for (let i = 1; i <= pdf.numPages; i++) {
          const pageDiv = $('<div class="page"></div>').attr('data-page', i);
          flipbook.append(pageDiv);
          
          if (i === 1) {
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: isWide() ? 1.2 : 1.0 });
            firstW = viewport.width;
            firstH = viewport.height;
          }
        }

        const bookW = isWide() ? firstW * 2 : firstW;
        const bookH = firstH;

        $('#loader').hide();
        flipbook.width(bookW).height(bookH).css('visibility', 'visible').turn({
          width: bookW, height: bookH,
          autoCenter: true,
          display: isWide() ? 'double' : 'single',
          acceleration: true,
          elevation: 50,
          gradients: !hapticCheck(), // 低スペック端末ではグラデーションを切る
          when: {
            turning: async function(e, page, view) {
              // 必要なページだけその都度描画する（もっさり解消！）
              view.forEach(async (p) => {
                if (p === 0) return;
                const container = $(`.page[data-page="${p}"]`);
                if (container.find('canvas').length === 0) {
                  const pdfPage = await pdf.getPage(p);
                  const viewport = pdfPage.getViewport({ scale: 1.5 });
                  const canvas = document.createElement('canvas');
                  canvas.width = viewport.width;
                  canvas.height = viewport.height;
                  await pdfPage.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                  container.append(canvas);
                }
              });
            }
          }
        });
        
        // 初回のみ1ページ目を描画
        $(`.page[data-page="1"]`).trigger('render'); 
      } catch (e) {
        console.error(e);
        $('#loader').text('エラーが発生しました。再読み込みしてください。');
      }
    }

    function hapticCheck() {
      return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    }

    $(window).on('load', () => setTimeout(buildFlipbook, 100));
  </script>
</body>
</html>
